{"meta":{"title":"CATSLAB BLOG","subtitle":null,"description":null,"author":"bychkim","url":"https://cantapiya.github.io/catslab_blog","root":"/catslab_blog/"},"pages":[],"posts":[{"title":"Kops Cluster","slug":"2019-04-25-k8s-kops-cluster","date":"2019-04-26T22:00:00.000Z","updated":"2019-04-24T11:50:05.256Z","comments":true,"path":"2019/04/27/2019-04-25-k8s-kops-cluster/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/04/27/2019-04-25-k8s-kops-cluster/","excerpt":"","text":".","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://cantapiya.github.io/catslab_blog/categories/Kubernetes/"},{"name":"Kops Cluster","slug":"Kubernetes/Kops-Cluster","permalink":"https://cantapiya.github.io/catslab_blog/categories/Kubernetes/Kops-Cluster/"}],"tags":[]},{"title":"AWS Settings","slug":"2019-04-25-k8s-AWS-settings-00","date":"2019-04-26T22:00:00.000Z","updated":"2019-04-24T11:48:48.134Z","comments":true,"path":"2019/04/27/2019-04-25-k8s-AWS-settings-00/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/04/27/2019-04-25-k8s-AWS-settings-00/","excerpt":"","text":".","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://cantapiya.github.io/catslab_blog/categories/Kubernetes/"},{"name":"AWS Settings","slug":"Kubernetes/AWS-Settings","permalink":"https://cantapiya.github.io/catslab_blog/categories/Kubernetes/AWS-Settings/"}],"tags":[]},{"title":"CATS Lab Installation","slug":"2019-04-25-catslab-install-00","date":"2019-04-25T22:00:00.000Z","updated":"2019-04-24T11:23:38.563Z","comments":true,"path":"2019/04/26/2019-04-25-catslab-install-00/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/04/26/2019-04-25-catslab-install-00/","excerpt":"","text":".","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Installation","slug":"CATS-LAB/Installation","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Installation/"}],"tags":[]},{"title":"A.0 Trade Basic","slug":"2019-02-25-catslab-trade-00-base-post","date":"2019-02-26T00:00:00.000Z","updated":"2019-04-24T09:01:05.046Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-00-base-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-00-base-post/","excerpt":"","text":"A.0. COZA package 및 필요한 모듈 및 함수 import 필수 BotContext 생성을 위해 import 합니다. 1from coza.bot import BotContext 거래소에 주문을 넣기 위한 Order 객체를 import 합니다. 1from coza.objects import Order 부가적으로 사용할 패키지 내의 객체나 함수 및 전략에서 이용할 TA들을 import 합니다. 1from coza.ta import (TA_NAME)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.1 BotContext의 생성","slug":"2019-02-25-catslab-trade-01-botcontext-post","date":"2019-02-25T23:00:00.000Z","updated":"2019-04-24T09:01:13.098Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-01-botcontext-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-01-botcontext-post/","excerpt":"","text":"A.1. BotContext의 생성BOT_NAME을 지정하여 아래의 parameter를 입력하여 BotContext를 생성할 수 있습니다.생성과 동시에 전략에서 사용할 가상화폐와 분봉들의 dataframe을 로드하여 저장합니다. 1234567BOT_NAME = BotContext(api_key, secret_key, init_budget, exchange, initialize, run_strategy, make_orders) A.1.1. api_key (str)거래소로부터 발급 받은 사용자의 거래소 api key를 입력합니다. A.1.2. secret_key (str)거래소로부터 발급 받은 사용자의 거래소 secret key를 입력합니다. A.1.3. init_budget (int)사용자의 Bot에서 사용할 자산의 초기 투입 금액을 입력합니다. A.1.4. exchange (str)Bot에서 가상 화폐 거래를 할 때 이용할 거래소의 명칭을 입력합니다.(해당 거래소에서 발급 받은 api key, secret key를 위의 입력 값으로 사용합니다.) A.1.5. initialize사용자가 Bot을 생성할 때 전략에서 사용할 가상화폐의 종류, 분봉, 거래소의 기축 화폐에 대한 정보와 safety setting에 대한 정보를 저장하는 함수입니다. 자세한 설명과 작성 예시는 A.3. initialize를 참고하시기 바랍니다. A.1.6. run_strategyBot에서 사용하는 전략에서 매수 및 매도를 위해 참고할 기술적 지표를 계산하여 저장하는 함수입니다.자세한 설명과 작성 예시는 A.4. run_strategy를 참고하시기 바랍니다. A.1.7. make_orders사용자가 정한 방식에 따라 매수주문/매도주문/주문취소 등을 진행하는 함수입니다.자세한 설명과 작성 예시는 A.5. make_orders를 참고하시기 바랍니다. dataframe에 접근하는 방식은 우선 BotContext를 생성할 때의 BOT_NAME class에서 exchanges로 접근하여 Bot에서 사용하는 거래소별 객체로 접근할 수 있습니다.각 거래소에서 data로 접근하여 ‘{currency}_{interval}’ 형태의 key값으로 가상화폐 별, 분봉 별 dataframe에 접근이 가능합니다. 생성된 dataframe의 형태는 다음과 같습니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.2 Trade 실행","slug":"2019-02-25-catslab-trade-02-run-post","date":"2019-02-25T22:00:00.000Z","updated":"2019-04-24T09:01:18.861Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-02-run-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-02-run-post/","excerpt":"","text":"A.2. Trade 실행BotContext로 지정한 BOT_NAME으로 context의 run 함수를 통해 Bot을 실행 시킬 수 있습니다.(예: BOT_NAME.run()) Bot을 실행하게 되면 context를 생성할 때 입력한 정보들과 함수들을 이용하여, 1분 주기로 다음과 같은 과정을 반복합니다. A.2.1. 현금과 가상화폐 보유량을 업데이트make_orders에서 생성하여 거래소로 전송한 거래 주문의 거래 체결 여부와 취소 여부를 확인하여 자산의 보유 현황을 업데이트하는 과정을 진행합니다. A.2.2. 현재 자산의 현금가 추정치를 계산업데이트된 보유 자산을 이용하여 현재 자산들의 현금가격 추정치를 계산합니다. A.2.3. initialize에서 입력한 safety setting의 조건을 만족하는지의 여부를 검사이전 단계에서 계산한 현금가의 추정치를 이용하여 사용자가 입력한 safety setting 조건의 만족 여부를 검사합니다. 이 단계에서 safety setting의 조건을 만족할 때, 사용자가 지정한 가동 중지의 여부에 따라 Bot의 가동을 중단 시키거나 계속해서 유지하게 됩니다. 아래의 과정은 Bot의 가동을 유지하는 경우에 진행됩니다. A.2.4. dataframe 업데이트사용자가 전략에 사용하기 위해 입력한 가상화폐와 분봉의 종류에 따라 dataframe 타입으로 캔들 데이터를 저장하는데, 1분 주기로 각 화폐와 각 분봉 별로 새롭게 캔들이 생성되었는지의 여부를 확인하여 dataframe을 업데이트 합니다. A.2.5. run_strategy 실행캔들 데이터 업데이트의 여부에 따라 전략에서 사용하는 지표를 업데이트 합니다. 새롭게 생성된 캔들 데이터가 존재하는 경우 업데이트 된 기점으로 새롭게 지표를 계산하여 저장합니다. A.2.6. make_orders 실행사용자가 지정한 과정을 거쳐 매수주문/매도주문/주문취소를 진행하는 함수를 실행합니다. 이 단계에서 생성한 매수주문/매도주문은 set_order 함수를 이용하여 주문내역에 저장하고, set_cancel 함수를 이용하여 기존에 전송한 주문에 대한 주문취소 요청을 진행합니다. A.2.7. 거래소 API를 이용하여 거래소로의 주문 요청이전 단계인 make_orders에서 생성한 주문들을 거래소 API를 사용하여 거래소로 주문 요청을 진행합니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.3 Initialze의 작성 및 사용 예시","slug":"2019-02-25-catslab-trade-03-initialize-post","date":"2019-02-25T21:00:00.000Z","updated":"2019-04-24T09:09:49.947Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-03-initialize-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-03-initialize-post/","excerpt":"","text":"A.3. initialize 함수의 작성 및 사용 예시Initialize 함수의 작성 형식은 다음과 같은 형식을 갖으며,123456789101112131415161718192021222324252627282930def initialize(self): self.context[‘trade_info’] = &#123;\"EXCHANGE_NAME_1\": &#123; \"currency\": [], \"interval\": [], \"fiat\": FIAT &#125;, \"EXCHANGE_NAME_2\": &#123; \"currency\": [], \"interval\": [], \"fiat\": FIAT &#125;, … , \"safety_setting\": &#123; \"profit_target\": &#123; \"checked\": bool, \"ratio\": RATIO &#125;, \"stop_loss\":&#123; \"checked\": bool, \"ratio\": RATIO &#125;, \"stop_on_sell\": bool, \"trailing_stop\": &#123; \"checked\": bool, \"dec_ratio\": RATIO, \"inc_ratio\": RATIO &#125; &#125; &#125; 실제로 작성한 예제는 다음과 같습니다. 12345678910111213141516171819202122232425262728def initialize(self):self.context['trade_info'] = &#123;\"coinone\": &#123; \"currency\": [\"xrp\"], \"interval\": [1], \"fiat\": \"krw\" &#125;, \"upbit\": &#123; \"currency\": [\"xrp\"], \"interval\": [1], \"fiat\": \"krw\" &#125;, \"safety_setting\": &#123; \"profit_target\": &#123; \"checked\": True, \"ratio\": 0.10, &#125;, \"stop_loss\": &#123; \"checked\": False, \"ratio\": 0.10 &#125;, \"stop_on_sell\": True, \"trailing_stop\": &#123; \"checked\": True, \"dec_ratio\": 0.05, \"inc_ratio\": 0.07 &#125; &#125; &#125; 각각의 파라미터들은 다음과 같은 속성을 갖습니다. A.3.1. “EXCHANGE_NAME”: {“currency”: [], “interval”: [], “fiat”: FIAT}Bot에서 사용할 거래소의 명칭 EXCHANGE_NAME을 key로 하여, 해당 거래소에서 사용할 가상화폐(currency)의 종류, 분봉(interval)의 종류, 기축화폐(fiat)의 정보를 dictionary 타입으로 입력합니다. A.3.1.1. “currency”: []EXCHANGE_NAME을 key값으로 하는 dictionary에서 가상화폐의 종류에 대한 정보는 “currency”를 key, 사용할 가상화폐의 종류가 저장된 list를 value값으로 합니다.(예: “currency”: [“btc”, “xrp”, “eth”]) A.3.1.2. “interval”: []A.2.2와 마찬가지로 사용할 분봉에 대한 정보는 “interval”을 key, 사용할 분봉의 종류가 저장된 list를 value값으로 합니다.(예: “interval”: [1, 5, 60]) A.3.1.3. “fiat”: FIAT거래소에서 사용하는 기축화폐의 정보의 경우 “fiat”를 key값으로 하고, string 타입의 FIAT를 value값으로 가집니다.(예: “fiat”: “krw” 또는 “fiat”: “usd”) A.3.2. “safety_setting”: {“profit_target”:{}, “stop_loss”:{}, “stop_on_sell”:bool, “trailing_stop”:{}}Bot에서 사용할 safety setting에 대한 정보 역시 “safety_setting”을 key값으로 하는 dictionary 타입으로 입력합니다. A.3.2.1. “profit_target”: {“checked”: bool, “ratio”: RATIO}Bot에서 사용할 익절 조건(“profit_target”)으로, 초기 투입 금액의 입력한 RATIO 이상으로 수익이 발생했을 시에 자동으로 Bot을 중단시키는 조건입니다. 이 기능을 사용할 것인지에 대한 여부를 “checked”를 key값, bool 타입의 value값으로 입력하고, 익절 조건의 비율을 float 타입의 RATIO (0&lt;=RATIO&lt;=1)로 입력합니다. A.3.2.2. “stop_loss”: {“checked”: bool, “ratio”: RATIO}Bot에서 사용할 손절 조건(“stop_loss”)으로, 초기 투입 금액의 입력한 RATIO 이하으로 손해가 발생했을 시에 자동으로 Bot을 중단시키는 조건입니다. 이 기능을 사용할 것인지에 대한 여부를 “checked”를 key값, bool 타입의 value값으로 입력하고, 손절 조건의 비율을 float 타입의 RATIO (0&lt;=RATIO&lt;=1)로 입력합니다. A.3.2.3. “stop_on_sell”: boolsafety setting의 조건을 만족하여 거래를 중단할 경우 보유하고 있던 가상화폐들을 청산할 것인지에 대한 여부를 “stop_on_sell”를 key값으로하여 bool 타입의 value를 입력합니다. A.3.2.4. “trailing_stop”: {“checked”: bool, “dec_ratio”: RATIO, “inc_ratio”: RATIO}Bot을 가동중에 입력한 RATIO(“inc_ratio”) 이상 수익이 발생한 경우, 이후 거래에서 “dec_ratio” 이하로 하락했을 시 Bot 가동을 중단시키는 기능입니다. 기능의 사용 여부를 “checked”를 key값, bool 타입의 value값으로 입력하고, 기능이 발동되는 기준인 상승 조건을 “inc_ratio”의 key값과 float 타입의 RATIO (0&lt;=RATIO&lt;=1)로 입력합니다. 상승 이후 하락 조건을 “dec_ratio”의 key값과 float 타입의 RATIO (0&lt;=RATIO&lt;=1)로 입력합니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.4 run_strategy 함수 작성 및 예시","slug":"2019-02-25-catslab-trade-04-run-strategy-post","date":"2019-02-25T20:00:00.000Z","updated":"2019-04-24T11:10:32.215Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-04-run-strategy-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-04-run-strategy-post/","excerpt":"","text":"A.4. run_strategy 함수의 작성 및 사용 예시1분 주기로 업데이트 되는 dataframe을 이용하여 사용자가 전략에서 사용하는 기술적 지표 및 매수/매도의 근거가 되는 전략을 계산하고 업데이트하는 함수입니다. 1def run_strategy(self, is_update, trade_info, update_len, data): A.4.1. is_update (dict)is_update parameter는 가상화폐와 분봉의 종류에 따라 “{currency}_{interval}” 형태의 key값과, 해당 분봉의 update 여부에 따라 bool 타입의 value값을 갖습니다. 예를 들어, 1분을 주기로 Trade 함수(A.2. 참고)가 진행될 때, 1분마다 생성되는 1분봉의 경우 매분 새롭게 캔들 데이터가 생성되어 dataframe 업데이트가 진행됩니다. 이외의 분봉들은 해당 분봉이 생성되고 나서 dataframe 업데이트의 여부에 따라 bool 타입의 value값이 is_update에 저장됩니다. A.4.2. trade_info (dict)전략에서 사용하는 거래소, 가상화폐, 분봉의 종류 및 safety setting에 대한 정보를 저장하고 있는 parameter입니다. 초기에 BotContext를 생성할 때 initialize(A.3. 참고)에서 입력한 정보들과 같습니다. A.4.3. update_len (dict)각각의 가상화폐와 분봉에 따라 1분 주기로 dataframe의 업데이트 여부를 is_update에 저장하는 것과 동시에 업데이트 된 캔들 데이터의 개수가 update_len에 저장됩니다. is_update와 마찬가지로 “{currency}_{interval}” 형태의 key값을 가지고, 업데이트 된 캔들 데이터의 개수를 value값으로 가집니다. 이 parameter는 실제 거래소에서 캔들 데이터가 생성되더라도 크롤링이나 거래소 API를 이용하여 데이터를 호출하는 과정에서 업데이트 되어야할 캔들 데이터가 누락 또는 지연이 되거나, 거래소 점검으로 인해 업데이트 되는 캔들 데이터가 없는 경우를 구분하기 위해 사용합니다. A.4.4. data (dict)전략에서 사용하기 위해 입력한 가상화폐의 종류와 분봉의 종류에 따라 “{currency}_{interval}” 형태의 key값과 dataframe을 value값으로 갖는 dictionary입니다. 각 dataframe에는 해당 가상화폐와 분봉의 캔들 데이터 및 전략에서 사용되는 기술적 지표들이 저장되어 있습니다. 또한, 각 분봉마다 가지고 있는 default 개수만큼을 가장 최근에 업데이트 된 캔들 데이터까지 저장하고 있습니다. 각 분봉의 default 개수는 다음과 같습니다.1분봉 : 10080개 (1주일)3분봉 : 3360개 (1주일)5분봉 : 8640개 (1개월)15분봉 : 2880개 (1개월)30분봉 : 1440개 (1개월)60분봉 : 2160개 (3개월)120분봉 : 1080개 (3개월)240분봉 : 540개 (3개월)1440분봉 : 365개 (1년) run_strategy 함수의 사용 예시는 5일 이동평균선과 20일 이동평균선을 사용하는 전략으로 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435from coza.ta import candle_slicingfrom coza.ta import emadef run_strategy(self, is_update, trade_info, update_len, data): exchange = self.exchange for currency in trade_info[exchange]['currency']: for interval in trade_info[exchange]['interval']: if int(interval) == 1: if len(is_update.keys()) != 0: update_number = update_len[f'&#123;currency&#125;_&#123;int(interval)&#125;'] update_candle_20 = \\ candle_slicing(df=df, n=20, update_number=update_number) update_candle_60 = \\ candle_slicing(df=df, n=60, update_number=update_number) update_ema_20 = \\ ema(update_candle_20['close'], 20).tail(update_number) update_ema_60 = \\ ema(update_candle_60['close'], 60).tail(update_number) if update_number &gt;= 1: start_index_20 = update_ema_20.index[0] start_index_60 = update_ema_60.index[0] for index in range(update_number): data[f'&#123;currency&#125;_&#123;int(interval)&#125;'].set_value(start_index+timedelta(days=index), 'ema_20', update_ema_20.loc[start_index+timedelta(days=index)]) data[f'&#123;currency&#125;_&#123;int(interval)&#125;'].set_value(start_index+timedelta(days=index), 'ema_60', update_ema_60.loc[start_index+timedelta(days=index)]) else: data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_20'] = \\ ema(data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['close'], 20) data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_60'] = \\ ema(data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['close'], 60)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.5 make_orders 함수의 작성 및 예시","slug":"2019-02-25-catslab-trade-05-make-orders-post","date":"2019-02-25T19:00:00.000Z","updated":"2019-04-24T09:01:36.096Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-05-make-orders-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-05-make-orders-post/","excerpt":"","text":"A.5. make_orders 함수의 작성 및 예시전략에서 사용하는 매수/매도 방식에 따라 매수주문/매도주문/주문취소를 진행합니다. 주문을 생성할 때는 Order 객체를 이용하여 생성하고, 생성한 주문들은 set_order 함수를 이용하여 주문 내역에 저장합니다. 주문 내역에 있는 주문들은 거래소 API를 이용하는 내부 함수를 사용하여 거래소로 전송됩니다. 주문 취소의 경우 set_cancel을 통해 거래소로 전송이 가능합니다. 주문을 생성하는 Order 객체 생성은 A.6.을 참고하시고, 생성한 주문을 거래소에 전송하기 위해 list에 추가하는 set_order 함수는 A.7.을 참고하시기 바랍니다. 또한, 체결 이전의 주문들의 정보를 저장하고 있는 order_list에 대한 내용은 A.8.에서, 주문 취소를 요청하는 set_cancel 함수에 대한 설명과 사용 방법은 A.9.을 참고하시기 바랍니다. 1def make_orders(self, is_update, trade_info, update_len, data): A.5.1. is_update (dict)run_strategy 함수의 parameter와 동일합니다. A.5.2. trade_info (dict)run_strategy 함수의 parameter와 동일합니다. A.5.3. update_len (dict)run_strategy 함수의 parameter와 동일합니다. A.5.4. data (dict)run_strategy 함수의 parameter와 동일합니다. make_orders 함수의 사용 예시는 다음과 같습니다. 다음 예시는 위의 run_strategy를 기반으로 5일 이동평균선이 20일 이동평균선을 상향 돌파하는 순간 매수, 하향 돌파하는 순간 매도하는 전략입니다. 12345678910111213141516171819202122232425262728293031def make_orders(self, is_update, trade_info, update_len, data): exchange = self.exchange interval = 1 total_fiat = self.exchanges[exchange].balance['fiat'] for currency in trade_info[exchange]['currency']: current_index = data[f'&#123;currency&#125;_&#123;int(interval)&#125;'].index[-1] t = current_index if data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_20'].loc[current_index-timedelta(seconds=60)] \\ &lt; data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_60'].loc[current_index-timedelta(seconds=60)] \\ and data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_20'].loc[current_index] \\ &gt; data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_60'].loc[current_index]: order_type = 'BUY' price = data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['close'].loc[current_index] quantity = math.floor( round (total_fiat*0.5 / price * 10**4, 4) )/(10**4) if quantity &gt;= 1.0 and price * quantity &lt;= self.exchanges[exchange].balance['fiat']: o = Order(exchange=exchange, currency=currency, order_type=order_type, fiat='krw', price=price, quantity=quantity) self.set_order(exchange=exchange, o=o, t=t) elif data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_20'].loc[current_index-timedelta(seconds=60)] \\ &gt; data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_60'].loc[current_index-timedelta(seconds=60)] \\ and data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_20'].loc[current_index] \\ &lt; data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['ema_60'].loc[current_index]: order_type = 'SELL' price = data[f'&#123;currency&#125;_&#123;int(interval)&#125;']['close'].loc[current_index] quantity = math.floor(round(self.exchanges[exchange].balance[currency]['avail'] * 10**4, 4))/(10**4) if quantity &gt;= 1.0: o = Order(exchange=exchange, currency=currency, order_type=order_type, fiat='krw', price=price, quantity=quantity) self.set_order(exchange=exchange, o=o, t=t)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.6 Order 객체 생성 및 사용 예시","slug":"2019-02-25-catslab-trade-06-order-post","date":"2019-02-25T18:00:00.000Z","updated":"2019-04-24T09:13:18.200Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-06-order-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-06-order-post/","excerpt":"","text":"A.6. Order 객체 생성 및 사용 예시거래소에 주문을 전송하기 전에 Order 객체를 생성하여 list에 저장을 한 뒤, 거래소 API를 이용하는 함수를 사용하여 list에 저장되어 있는 주문들을 한 번에 처리합니다. 1class Order(exchange, currency, order_type, quantity, price, fiat): A.6.1. exchange (str)주문할 거래소의 명칭을 입력합니다.(예: ‘coinone’, ‘upbit’) A.6.2. currency (str)거래소에 주문을 넣을 가상 화폐의 명칭을 입력합니다.(예: “btc”, “eth”, “xrp”, … ) A.6.3. order_type (str)매수와 매도를 구분하기 위한 parameter입니다.매수 주문의 경우 “BUY”, 매도 주문의 경우 “SELL” 타입으로 입력합니다. A.6.4. quantity (float)주문할 가상화폐의 수량을 입력합니다. A.6.5. price (int)주문할 가상화폐의 가격을 입력합니다. A.6.6. fiat (str)거래소에서 사용하는 기축화폐를 입력합니다.(예: “krw”, “usd”, … ) Order 객체의 사용 예시는 다음과 같습니다. 매수주문 (현재 가격으로 주문): 1234from coza.objects import Orderprice = data[f'&#123;currency]_&#123;int(interval)&#125;']['close'].loc[data[f'&#123;currency]_&#123;int(interval)&#125;'].index[-1]]buy_order = Order(exchange='coinone', currency='xrp', order_type='BUY', fiat='krw', price=price, quantity=2.5) 매도주문 (지정가 주문):123from coza.objects import Ordersell_order = Order(exchange='upbit', currency='eth', order_type='SELL', fiat='krw', price=150000, quantity=0.1)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.7 set_order 함수의 사용과 예시","slug":"2019-02-25-catslab-trade-07-set-order-post","date":"2019-02-25T17:00:00.000Z","updated":"2019-04-24T09:14:21.019Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-07-set-order-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-07-set-order-post/","excerpt":"","text":"A.7. set_order 함수의 사용과 사용과 예시Order 객체를 이용하여 생성한 주문들을 거래소 API를 이용하여 거래소에 전송을 하기 위한 함수입니다. 주문내역에 대한 정보를 저장하는 Order 객체와, 주문 시간을 지정하여 list에 추가한 뒤, 내부 함수를 이용하여 list 저장되어 있는 주문을 거래소로 전송을 합니다. 거래소로 전송함과 동시에 자산의 보유량을 업데이트하여 변경된 정보를 저장합니다. 보유 자산을 업데이트할 때는 수수료를 고려하여 적용이 됩니다. 1def set_order(self, exchange, o, t=None): A.7.1. exchange (str)Bot에서 사용하는 거래소의 명칭을 입력합니다. A.7.2. o (object)make_orders에서 Order 객체를 사용하여 생성하며, 주문할 가상화폐의 종류, 주문 유형, 주문 수량, 주문 가격, 거래소에서 사용하는 기축화폐에 대한 정보를 포함합니다. A.7.3. t (datetime.datetime)주문을 요청하는 시간을 입력합니다. 별도로 지정하지 않는 경우 현재시간을 이용하여 주문 시간이 정해집니다. 1234567891011121314from coza.objects import Orderfrom datetime import datetime# 현재 시간으로 주문price = data[f'&#123;currency]_&#123;int(interval)&#125;']['close'].loc[data[f'&#123;currency]_&#123;int(interval)&#125;'].index[-1]]buy_order = Order(exchange='coinone', currency='xrp', order_type='BUY', fiat='krw', price=price, quantity=2.75)order_time = datetime.now()set_order(exchange='coinone', o=buy_order, t=order_time)# 주문 신호가 들어온 캔들의 시간으로 주문sell_order = Order(exchange='upbit', currency='eth', order_type='SELL', fiat='krw', price=175000, quantity=0.1)t = data[f'&#123;currency]_&#123;int(interval)&#125;'].index[-1]set_order(exchange='upbit', o=sell_order, t=t)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.8 Order_list","slug":"2019-02-25-catslab-trade-08-order-list-post","date":"2019-02-25T16:00:00.000Z","updated":"2019-04-24T09:15:26.793Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-08-order-list-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-08-order-list-post/","excerpt":"","text":"A.8. order_listOrder 객체를 이용하여 생성된 주문은 내부 함수를 거쳐 거래소로 전송된 뒤에 BotContext의 exchanges 내부 order_list에 저장됩니다. order_list는 가상화폐 종류를 key값으로 한 dictionary 내부에 다시 order_id를 key값으로하고 해당 order_id의 주문 정보를 포함하는 Order 객체를 value값으로 하는 dictionary로 형태로 관리됩니다. 주문한 수량의 전체가 체결이 되거나, 전체가 취소될 경우 order_list에서 제거가 되며, 자산의 업데이트가 진행됩니다. 부분 체결 및 부분 취소가 발생한 경우에도 자산의 업데이트가 진행되며, 미체결 수량이 존재하는 경우에는 remain_qty에 그 수량을 저장합니다. order_list에 대한 예시는 다음과 같습니다. coinone_bot이라는 BotContext에 저장되어 있는 order_list로, ‘iota’와 ‘xrp’에 관련된 미체결 주문 정보가 저장되어 있는 것을 볼 수 있습니다. Order 객체에 저장된 주문 정보들은 다음과 같습니다. A.8.1. currency주문한 가상화폐의 명칭을 저장합니다. A.8.2. fee주문한 수량을 기준으로 계산한 수수료에 대한 정보입니다. ‘order_type’이 ‘SELL’인 경우 ‘fee’에 저장된 값은 Bot에서 사용하는 거래소의 기축화폐에 해당합니다. A.8.3. fiatBot에서 사용하는 거래소의 기축화폐의 정보입니다. A.8.4. order_type매수 주문인지 매도 주문인지 구분하는 역할을 합니다. A.8.5. price주문 가격에 대한 정보입니다. A.8.6. quantity주문한 수량에 대한 정보입니다. A.8.7. remain_qty주문한 수량에서 부분 체결이나 부분 취소가 발생하고 난 뒤의 미체결 된 주문 수량에 대한 정보입니다. A.8.8. timestamp주문한 시간의 timestamp값에 대한 정보입니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.9 set_cancel 함수의 사용과 사용 예시","slug":"2019-02-25-catslab-trade-09-set-cancel-post","date":"2019-02-25T15:00:00.000Z","updated":"2019-04-24T10:39:23.928Z","comments":true,"path":"2019/02/26/2019-02-25-catslab-trade-09-set-cancel-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/26/2019-02-25-catslab-trade-09-set-cancel-post/","excerpt":"","text":"A.9. set_cancel 함수의 사용과 사용 예시거래소에 전송한 주문 중 미체결 주문들을 취소할 때 사용할 수 있는 함수입니다. 1def set_cancel(self, exchange, currency=None, order_id=None, qty=None): A.9.1 exchange (str)Bot에서 사용하는 거래소의 명칭을 입력합니다. A.9.2. currency (str)취소할 주문의 가상화폐를 입력합니다.(예: “btc”, “eth”, “xrp”, … ) A.9.3. order_id (str)취소할 주문의 order_id를 입력합니다.order_id를 입력하여 주문을 취소하는 경우 currency를 함께 입력해야 합니다. A.9.4. qty (float)주문 취소할 수량을 입력합니다.수량을 입력하지 않는 경우 입력한 currency 또는 currency의 order_id에 남아 있는 주문 수량 전체를 취소합니다. 단, 부분 취소의 경우 coinone 거래소에서만 제공하며, upbit 거래소에서는 부분취소 기능을 제공하지 않습니다.upbit 거래소의 경우 qty를 입력하더라도(currency와 order_id도 함께) 미체결 주문의 모든 수량을 주문취소합니다. 다음은 주문을 취소하는 4가지 방법에 대한 예시입니다. 4개의 ‘XRP’ 주문이 들어간 상태에서 거래소의 미체결 주문 현황과 Bot의 order_list에 저장되어 있는 주문들에 대한 정보입니다. cancel #4 (특정 미체결 주문의 부분 취소)1set_cancel(exchange=EXCHANGE_NAME, currency=CURRENCY, order_id=ORDER_ID, qty=QUANTITY) 입력 받은 거래소의 해당 가상 화폐와 order_id를 갖는 주문을 입력받은 수량 만큼 부분 취소합니다.입력한 qty가 미체결 수량보다 많은 경우 전체 수량을 취소하고, 적은 경우에는 부분 취소합니다. 주문 수량이 1이었던 주문을 0.5 수량만큼을 부분 취소하는 경우 order_list에서 해당 order_id의 remain_qty가 0.5로 남아 있는 것과, 거래소 미체결 주문 현황에 주문잔량이 0.5000으로 저장되어 있는 것을 확인할 수 있습니다. cancel #3 (특정 미체결 주문 전체 취소)1set_cancel(exchange=EXCHANGE_NAME, currency=CURRENCY, order_id=ORDER_ID) qty를 입력하지 않는 경우 해당 가상화폐의 order_id를 갖는 주문의 미체결 수량 전체를 취소합니다. cancel #2 (특정 거래소, 특정 가상 화폐의 미체결 주문 전체 취소)1set_cancel(exchange=EXCHANGE_NAME, currency=CURRENCY) order_id를 입력하지 않고 가상화폐에 대한 정보만 입력한 경우 입력한 거래소의 currency에 해당하는 주문을 전부 취소합니다. 거래소 명칭과 전체 취소할 가상화폐만을 입력한 경우, order_list와 거래소 미체결 주문 현황에 저장되어 있던 이전의 ‘XRP’ 주문들이 순차적으로 취소되어 모두 취소된 것을 확인할 수 있습니다. cancel #1 (특정 거래소의 미체결 주문 전체 취소)1set_cancel(exchange=EXCHANGE_NAME) 거래소의 명칭만 입력한 경우, 입력 받은 거래소에 전송된 주문에 대하여 가상화폐의 종류, 남은 수량과 관계 없이 모든 미체결 주문을 전체를 취소합니다. ‘XRP’와 ‘MIOTA’가 각각 수량 1 씩 주문된 상태에서, 거래소 명칭(예시에서는 ‘coinone’)만을 입력하여 set_cancel 함수를 호출한 경우 두 가상화폐의 미체결 주문들이 모두 취소 된 것을 확인할 수 있습니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"A.10. 부가적인 기능의 함수들과 사용 예시","slug":"2019-02-25-catslab-trade-10-others-post","date":"2019-02-25T14:00:00.000Z","updated":"2019-04-24T10:44:29.889Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-trade-10-others-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-trade-10-others-post/","excerpt":"","text":"A.10. 부가적인 기능의 함수들과 사용 예시거래소별 API를 사용하는 함수에 접근하고, 거래소별 자산, 주문 현황, 체결 현황과 같은 정보에 접근하기 위해서는 Bot을 생성할 때 입력한 거래소의 명칭을 key값으로 가지는 exchanges class에 접근하여 사용이 가능합니다. 전략을 구현하고, Bot을 가동하는 과정에서 실시간으로 사용자의 Bot에 저장되어 있는 정보를 불러오는 함수들과 사용 예시들은 다음과 같습니다. 다음 예시는 “XRP”와 “MIOTA”를 각각 2개씩 매수주문을 넣은 상태에서 각각의 함수를 조회한 예시입니다. A.10.1. get_balance 함수거래소의 자산 보유량을 실시간으로 조회하는 함수입니다. 다음 예시는 현재의 ‘coinone’ 거래소의 자산 현황을 조회한 결과입니다. 초기 투입금액에서 “XRP”와 “MIOTA”를 각각 2개씩 매수주문을 넣은 상태에서의 자산 변화를 볼 수 있습니다. A.10.2. get_time 함수현재 시간을 datetime 타입으로 불러오는 get_time 함수입니다. A.10.3. get_order_list 함수현재 거래소의 미체결 주문 정보를 실시간으로 불러오는 함수입니다. A.10.4. get_orders 함수Order 객체를 사용하여 set_order 함수(A.7. set_orders 참고)를 사용하게 되면, 생성한 주문들을 내부 함수를 이용하여 거래소로 전송하기 이전에 orders라는 list에 임시적으로 저장을 해 둡니다. 1분마다 스케쥴링을 반복하면서 orders에 추가된 주문을 주문이 지정된 시간별로 거래소로 전송하여 처리하게 됩니다. 전송된 주문들은 orders list에서 빠지게 되고, 미체결된 주문은 order_list에서 관리하게 됩니다. orders에 저장된 주문은 전송하는 시간을 기점으로 하여 이전의 주문들은 모두 전송하는 방식으로 처리됩니다. 즉, 주문을 생성할 때 현재 시간, 혹은 이전의 시간으로 지정한 경우 다음 스케쥴링에서 거래소로 주문이 전송되며, 주문 시간을 지정하여 나중에 주문이 전송되도록 설정할 수도 있습니다. 예를 들어, 현재 시간의 한 시간 뒤의 시간으로 주문을 지정하는 경우 1시간 뒤 스케쥴링에서 거래소로 전송됩니다. get_orders 함수는 현재 orders에 저장되어 있는 주문들의 list를 불러오는 함수입니다. A.10.5. calc_estimated 함수calc_estimated 함수는 현재 보유하고 있는 모든 자산의 현금 평가가격을 계산하여 반환해주는 함수입니다. 다음 예시는 “XRP”와 “MIOTA”를 각각 2개씩의 매수주문을 넣고, “XRP”의 주문이 모두 체결 된 상태에서 get_balance, get_order_list, calc_esimated 함수를 조회한 예시입니다. 주문이 체결 됬기 때문에 보유한 자산 목록에 avail이 증가한 것을 확인할 수 있고, 미체결 주문 리스트인 order_list에는 체결되지 않은 “MIOTA”의 주문이 남아 있는 상태입니다. 이때, calc_estimated 함수를 조회하여 조회 시점의 가상화폐의 가격을 기준으로 하여 계산한 현금 평가가격을 확인할 수 있습니다. A.10.6. clear_balance 함수clear_balance 함수는 현재 보유하고 있는 가상화폐들을 호가창의 정보를 이용하여 바로 청산을 하는 기능을 수행합니다. 보유하고 있는 가상화폐의 호가창의 가장 높은 금액으로 매도 주문을 넣습니다. 위의 예시에 이어지는 상황으로, “XRP” 주문이 체결된 후 clear_balance 함수를 호출하면 보유하고 있던 1.998개의 “XRP”를 바로 청산 주문을 하여 체결이 된 것을 확인할 수 있습니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Trade","slug":"CATS-LAB/Trade","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Trade/"}],"tags":[]},{"title":"B.0 Backtest 기본","slug":"2019-02-25-catslab-backtest-00-base-post","date":"2019-02-24T21:00:00.000Z","updated":"2019-04-24T09:00:24.247Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-00-base-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-00-base-post/","excerpt":"","text":"B.0. Backtest 기본B.0. COZA package 및 필요한 모듈 및 함수 import 필수 BacktestContext 생성을 위해 import 합니다.1from coza.backtest import BacktestContext backtest에서 가상으로 주문을 넣기 위한 Order 객체를 import 합니다.1from coza.objects import Order 부가적으로 사용할 패키지 내의 객체나 함수 import 전략에서 이용할 TA들을 import 합니다.1from coza.ta import (TA_NAME)","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]},{"title":"B.1 BacktestContext의 생성","slug":"2019-02-25-catslab-backtest-01-context-post","date":"2019-02-24T20:00:00.000Z","updated":"2019-04-24T09:00:34.612Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-01-context-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-01-context-post/","excerpt":"","text":"B.1. BacktestContext의 생성BACKTEST_NAME을 지정하여 아래의 parameter를 입력하여 BacktestContext를 생성할 수 있습니다. 12345678BACKTEST_NAME = BacktestContext(user_uuid, initialize, run_strategy, make_orders, use_data, data_path, save_result, return_result) B.1.1. user_uuidCats Lab에서 발급 받은 사용자의 user_uuid를 입력합니다. B.1.2. initializeA. Trade의 initialize 함수와 동일합니다. B.1.3. run_strategyA. Trade의 run_strategy 함수와 동일합니다. B.1.4. make_ordersA. Trade의 make_orders 함수와 동일합니다. B.1.5. use_data (str, ‘LIVE’ 또는 ‘LOCAL’)use_data = “LIVE”로 입력할 경우 거래소 API를 이용하여 입력한 기간만큼의 캔들 데이터를 실시간으로 호출하여 사용합니다. use_data = “LOCAL”로 입력할 경우 지정한 경로(B.1.6. data_path)의 입력한 가상화폐와 분봉에 해당하는 CSV 파일을 로드하여 사용합니다. B.1.6. data_path (str)B.1.5. use_data에서 ‘LOCAL’ 모드로 입력하여 사용하는 경우, 캔들 데이터로 사용할 CSV 파일들의 경로를 입력합니다. B.1.7. return_result (bool)백테스트의 결과를 반환할 것인지에 대한 여부를 bool 타입으로 입력합니다. 로컬에서 백테스트를 실행할 경우 백테스트 결과를 확인하기 위해 True로 입력하여 반환 받은 result 객체로 접근이 가능합니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]},{"title":"B.2 Backtest 실행","slug":"2019-02-25-catslab-backtest-02-run-post","date":"2019-02-24T19:00:00.000Z","updated":"2019-04-24T09:00:39.666Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-02-run-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-02-run-post/","excerpt":"","text":"B.2. Backtest 실행생성한 BacktestContext를 run 함수를 이용하여 백테스트를 실행시킵니다.결과를 저장할 RESULT_NAME을 지정합니다. 12345RESULT_NAME = BACKTEST_NAME.run(start_date, end_date, exchange, init_budget, slippage_rate) B.2.1. start_date (datetime.datetime)백테스트를 실행할 기간 중 시작 시점의 datetime을 입력합니다. B.2.2. end_date (datetime.datetime)백테스트를 실행할 기간 중 종료 시점의 datetime을 입력합니다. B.2.3. exchange (str)백테스트를 실행할 때에 사용할 거래소의 명칭을 입력합니다. B.2.4. init_budget백테스트의 초기 투입 자산을 입력합니다. B.2.5. slippage_rate백테스트를 실행할 때 고려할 슬리피지 비율을 입력합니다. 실제 거래와 달리 백테스트에서는 주문한 매수주문/매도주문은 즉시 체결된 것으로 간주하여 결과를 반영하기 때문에, 실제 거래에서 발생할 수 있는 주문 미체결의 문제와 호가의 차이를 고려한 것이 슬리피지 비율입니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]},{"title":"B.3 ~ B.6 initialize, run_strategy, make_orders, Order 작성","slug":"2019-02-25-catslab-backtest-03-07-initialize-run-strategy-make-orders-order-post","date":"2019-02-24T18:00:00.000Z","updated":"2019-04-24T09:00:43.699Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-03-07-initialize-run-strategy-make-orders-order-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-03-07-initialize-run-strategy-make-orders-order-post/","excerpt":"","text":"B.3. ~ B.6. initialize, run_strategy, make_orders, Order 작성B.3. initialize의 작성A. Trade의 initialize 함수와 동일합니다. B.4. run_strategy 작성기본적으로 A. Trade의 make_orders 함수와 동일하나 1분 주기로 dataframe을 업데이트하고 그에 따른 기술적 지표를 업데이트하는 Trade에서와는 달리, Backtest에서는 dataframe의 업데이트가 발생하지 않고 처음 BacktestContext를 생성할 때 입력된 기간동안의 dataframe 및 기술적 지표를 한 번에 연산하여 저장합니다. 백테스트를 실행하면 사용자가 입력한 가상화폐와 분봉들마다 저장해놓은 dataframe을 순차적으로 잘라서 가져오는 방식이기 때문에 1분 주기로 run_strategy를 실행하는 과정이 생략됩니다. B.5. make_orders 작성A. Trade의 make_orders 함수와 동일합니다. B.6. Order 객체 생성A. Trade의 Order 객체와 동일합니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]},{"title":"B.7 Result 객체의 생성 및 사용 예시","slug":"2019-02-25-catslab-backtest-07-result-post","date":"2019-02-24T17:00:00.000Z","updated":"2019-04-24T11:07:10.553Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-07-result-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-07-result-post/","excerpt":"","text":"B.7. Result 객체의 생성 및 사용 예시생성한 BacktestContext를 run 함수를 이용하여 백테스트를 실행시킨 뒤 그 결과를 Result 객체로 생성하여 저장 및 반환합니다. Result 객체에 저장되어 있는 정보는 아래와 같습니다. 백테스트 결과를 도식화 하는 plot 함수의 기능은 B.8. plot을 참고하시기 바랍니다. 백테스트 결과를 저장하기 위해 지정한 RESULT_NAME을 이용하여 각각의 정보로 접근할 수 있습니다. 1RESULT_NAME = BacktestContext_NAME.run(start_date, end_date, exchange, init_budget, slippage_rate) B.7.1. created_time백테스트를 실행하여 Result 객체를 생성한 시간에 대한 정보입니다. B.7.2. elapsed_time백테스트를 수행하는 데에 소요된 전체 경과시간에 대한 정보입니다. B.7.3. earning_rate백테스트 초기 투입 자산 대비 종료 시점의 자산의 수익률을 나타내는 정보입니다. B.7.4. final_balance백테스트 종료 후 최종 시점의 자산 보유량에 대한 정보입니다. B.7.5. estimated_list백테스트를 진행하는 과정에서 매수 또는 매도가 발생했을 때의 거래 정보 및 그 시점에 보유한 모든 자산의 현금 평가가격에 대한 정보를 저장하고 있는 list입니다. estimated_list에 저장되는 정보의 타입은 ‘datetime’이 key값이고 거래가 발생하는 시점의 datetime을 value값으로 갖는 정보와 ‘estimated’가 key값이고 그 시점의 현금 평가가격을 value값으로 가지는 dictionary 타입입니다. B.7.6. total_fee백테스트를 진행하는 과정에서 일어난 거래들의 총 수수료를 나타내는 정보입니다. B.7.7. total_slippage백테스트를 진행하는 과정에서 입력한 slippage_rate을 기반으로 계산한 총 슬리피지 비용을 나타내는 정보입니다. B.7.8. max_profit백테스트를 진행하는 과정에서 최대로 얻은 이익의 수익률에 대한 정보입니다. B.7.9. max_loss백테스트를 진행하는 과정에서 최대로 손실을 보게 된 시점의 수익률에 대한 정보입니다. B.7.10. trade_history백테스트 진행 과정에서 일어난 모든 거래에 대한 정보를 저장하고 있는 dictionary입니다. 거래가 일어난 시점의 datetime을 key값으로 하고, 거래가 일어난 시점의 자산 보유 현황(‘balance’)과, 수익률(‘earning_rate’), 평가가격(‘estimated’), Order 객체로 생성되어 저장되어 있는 ‘order_list’에 대한 정보가 포함되어 있습니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]},{"title":"B.8 plot 함수의 사용 방법 및 사용 예시","slug":"2019-02-25-catslab-backtest-08-plot-post","date":"2019-02-24T16:00:00.000Z","updated":"2019-04-24T11:07:55.187Z","comments":true,"path":"2019/02/25/2019-02-25-catslab-backtest-08-plot-post/","link":"","permalink":"https://cantapiya.github.io/catslab_blog/2019/02/25/2019-02-25-catslab-backtest-08-plot-post/","excerpt":"","text":"B.8. plot 함수의 사용 방법 및 사용 예시Result 객체를 이용하여 사용할 수 있는 plot 함수는 백테스트에 이용한 가상화폐의 가격(종가 기준)의 변화와 백테스트 과정에서 거래가 발생한 시점마다 저장 되는 평가가격을 기반으로 자산의 변화를 도식화시켜주는 함수입니다. 이 함수의 사용 방법은 다음과 같습니다. 1def plot(add_marker, current_list, main_interval) B.8.1. add_marker (bool)거래가 발생하는 시점을 매수와 매도를 구분하여 marker로 표시할지에 대한 여부를 입력합니다. plot 함수는 기본적으로 백테스트 기간 동안 거래에 이용한 가상화폐의 가격 변화 그래프를 보여주는데, add_marker=True로 입력하는 경우 거래가 발생한 매 시점의 가격이 매수주문과 매도주문을 구분하여 가격 변화 그래프 위에 표시됩니다. B.8.2. currenct_list그래프를 그릴 때, 사용자가 도식화하고자 하는 가상화폐의 종류를 입력합니다. 한 가지 가상화폐만 입력할 수도 있고, 여러 개를 입력하는 경우 여러 가상화폐의 가격 변화를 하나의 그래프에 동시에 나타낼 수도 있습니다. B.8.3. main_interval입력한 가상화폐의 가격 변화를 종가를 기준으로 하여 그래프를 그리는데, 종가가격의 기준이 되는 분봉을 입력하는 parameter입니다. plot 함수의 사용 예시는 다음과 같습니다.","categories":[{"name":"CATS LAB","slug":"CATS-LAB","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/"},{"name":"Backtest","slug":"CATS-LAB/Backtest","permalink":"https://cantapiya.github.io/catslab_blog/categories/CATS-LAB/Backtest/"}],"tags":[]}]}